using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Loader;
using Core.ECS;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;

namespace Tests;

[TestFixture]
public class GeneratorTests
{
    private Assembly? _generatedAssembly;

    [Test]
    [Order(1)]
    public void GeneratorTest()
    {
        // Create the 'input' compilation that the generator will act on
        var inputCompilation = CreateCompilation(@"
using Core.ECS;

namespace ClassLibrary;

public struct TestComponentInClass : IComponent
{
    public string Test => ""this is a test component"";
}");

        var generator = new Generator.Component.Generator();

        // Create the driver that will control the generation, passing in our generator
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        // Run the generation pass
        // (Note: the generator driver itself is immutable, and all calls return an updated version of the driver that you should use for subsequent calls)
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out _);

        var runResult = driver.GetRunResult();

        // The runResult contains the combined results of all generators passed to the driver
        Assert.AreEqual(runResult.GeneratedTrees.Length,
                        1,
                        "Different number of syntax trees generated by the source generator");
        Assert.IsFalse(
            runResult.Diagnostics.Any(diagnostic =>
                                          diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error),
            "There were errors during the source generation");

        using var peStream = new MemoryStream();
        using var pdbStream = new MemoryStream();

        var emitRes = outputCompilation.Emit(peStream, pdbStream);
        Assert.IsTrue(emitRes.Success,
                      $"Couldn't emit resulting compilation successfully : {emitRes.Diagnostics.Select(d => d.GetMessage()).Aggregate((l, r) => l + Environment.NewLine + r)}");

        peStream.Position = 0;
        pdbStream.Position = 0;
        var assembly = AssemblyLoadContext.Default.LoadFromStream(peStream, pdbStream);
        Assert.IsNotNull(assembly, "Compiled assembly was not loaded successfully");

        _generatedAssembly = assembly;
    }

    [Test]
    [Order(2)]
    public void ComponentStoreTest()
    {
        var storeType = _generatedAssembly!.GetType("Core.ECS.Generated.ComponentStore");
        Assert.IsNotNull(storeType, "Couldn't find component store type");

        var testComponentInClassType = _generatedAssembly.GetType("ClassLibrary.TestComponentInClass");
        Assert.IsNotNull(testComponentInClassType, "Couldn't find input test component type");

        var store = Activator.CreateInstance(storeType!) as IComponentStore;
        Assert.IsNotNull(store, "Couldn't instantiate generated component store type");

        for (var i = 0; i < 1000; i++)
        {
            var c = new TestComponent { Index = i };
            store!.Add(in c);
        }

        for (ulong i = 0; i < 1000; i++)
        {
            ref var c = ref store!.Get<TestComponent>(i);
            Assert.AreEqual(i, c.Index, "Continuity error in component insertion");
        }
    }

    private static IEnumerable<MetadataReference> GetDotNetReferences()
    {
        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location)!;

        return new[]
        {
            Path.Combine(assemblyPath, "mscorlib.dll"),
            Path.Combine(assemblyPath, "System.dll"),
            Path.Combine(assemblyPath, "System.Core.dll"),
            Path.Combine(assemblyPath, "System.Runtime.dll")
        }.Select(s => MetadataReference.CreateFromFile(s));
    }

    private static Compilation CreateCompilation(string source) =>
        CSharpCompilation.Create("compilation",
                                 new[] { CSharpSyntaxTree.ParseText(source) },
                                 GetDotNetReferences()
                                     .Concat(new[]
                                     {
                                         typeof(Binder), typeof(Unsafe), typeof(IComponent), typeof(TestComponent)
                                     }.Select(t => t.GetTypeMetadataRef())),
                                 new(OutputKind.DynamicallyLinkedLibrary));
}